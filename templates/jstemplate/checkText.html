<script>
let grammarCheckTimeout;
let grammarErrors = {};
let lastTextVersion = "";

quill.on('text-change', () => {
    if (grammarCheckTimeout) clearTimeout(grammarCheckTimeout);
    grammarCheckTimeout = setTimeout(() => {
        checkGrammarInRealTime();
    }, 2000);
});

function highlightErrors(errors) {
    grammarErrors = {};

    let offset = 0;
    quill.getContents().ops.forEach(op => {
        const length = op.insert.length || 1; // Utiliser 1 pour des caractères simples
        if (op.attributes && op.attributes.background === '#f2a0a0') {
            quill.formatText(offset, length, { background: false });
        }
        offset += length;
    });

    errors.forEach(error => {
        grammarErrors[error.offset] = {
            suggestions: error.suggestions.slice(0, 5),
            length: error.length
        };
        quill.formatText(error.offset, error.length, {
            background: '#f2a0a0',
        });
    });
}


function checkGrammarInRealTime() {
    const text = quill.getText();
    
    if (text === lastTextVersion) {return;}
    lastTextVersion = text;

    const projectId = {{ id }};

    fetch('/check_grammar', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ text: text, project_id: projectId })
    })
    .then(response => response.json())
    .then(data => {
        if (text === lastTextVersion) {
            highlightErrors(data);
        }
    })
    .catch(error => {
        console.error("Erreur lors de la vérification grammaticale :", error);
    });
}

document.getElementById("editorjs").addEventListener("contextmenu", function(event) {
    const blot = Quill.find(event.target);

    if (blot && blot.domNode.innerText.length) {
        const errorLength = blot.domNode.innerText.length;
        let offset = 0;
        let found = false;

        Array.from(quill.root.childNodes[0].childNodes).forEach(child => {
            if (found) return;
            if (child === blot.domNode) {
                found = true;
            } else {
                offset += child ? child.length : 0;
            }
        });

        const error = grammarErrors[offset];
        if (error && error.suggestions) {
            event.preventDefault();
            showSuggestionsMenu(event, error.suggestions, offset, error.length);
        }
    }
});


function showSuggestionsMenu(event, suggestions, index, errorLength) {
    const menu = document.createElement("div");
    menu.classList.add("suggestions-menu");

    menu.style.top = `${event.clientY + window.scrollY}px`;
    menu.style.left = `${event.clientX + window.scrollX}px`;

    suggestions.forEach(suggestion => {
        const option = document.createElement("div");
        option.classList.add("suggestion-option");
        option.innerText = suggestion;

        option.onclick = () => {

            quill.deleteText(index, errorLength);
            quill.insertText(index, suggestion);

            menu.remove();
        };
        
        menu.appendChild(option);
    });

    document.body.appendChild(menu);
    document.addEventListener("click", () => menu.remove(), { once: true });
}
</script>